00:23:48 [Task3] compile
00:23:56 [Task3] load binary
00:24:02 [Task3] read source code
00:24:30 [Task3] run simulation
00:24:32 [Task3] set Entry State
00:24:46 [Task3] scroll through Function List
00:25:24 [Task3] look at disassembly code of main
00:25:45 [Task3] look at disassembly code of grub_mini_cmd_lsmod
00:25:56 [Task3] read task description
00:26:39 [Task3] search for main in function list
00:27:07 [Task3] note down suggestions to sedbg
00:28:23 [Task3] sudo apt install file
00:28:38 [Task3] note down suggestions to sedbg
00:29:05 [Task3] read task description
00:31:23 [Task3] gedit main
00:31:36 [Task3] gedit main.c 2>/dev/null &disown
00:31:39 [Task3] scroll through source code
00:31:52 [Task3] read task description
00:32:04 [Task3] compile
00:32:24 [Task3] gedit x.py >/dev/null &disown
00:32:34 [Task3] edit x.py
import angr
import claripy
00:32:41 [Task3] read source code
00:35:12 [Task3] edit x.py
import angr
import claripy
p = angr.Project('./main_angr')
f = angr.SimFile('symbolic_stdin', size=0x200)
entry = p.factory.entry_state(stdin=f)
s = p.factory.simgr()
avoids = []
00:38:18 [Task3] ghidra main_angr
00:39:32 [Task3] read source code
00:41:16 [Task3] run program
00:41:27 [Task3] try input IXzzzzzzzz | IZA,A,A,A,A,
00:42:21 [Task3] try input IXA,A,A,A,
00:42:33 [Task3] try input DA
00:42:53 [Task3] try input DD
00:43:06 [Task3] analyze source code (focus on main)
00:43:53 [Task3] analyze source code (focus on grub_mini_cmd_insmod)
00:44:16 [Task3] man xstrdup
00:44:31 [Task3] unminimize && sudo apt install man-db
00:46:40 [Task3] analyze source code (focus on grub_dl_unload)
00:47:07 [Task3] read source code
00:47:58 [Task3] analyze source code (focus on grub_mini_cmd_insmod)
00:48:08 [Task3] add comment in source code
00:49:30 [Task3] scroll through source code
00:49:55 [Task3] analyze source code (focus on grub_mini_cmd_insmod)
00:51:15 [Task3] scroll through source code
00:52:14 [Task3] analyze source code (focus on grub_dl_resolve_dependencies)
00:52:56 [Task3] scroll through source code
00:58:53 [Task3] read task description
00:59:16 [Task3] scroll through disassembly code
00:59:43 [Task3] focus on main
01:01:38 [Task3] file main_angr
01:01:53 [Task3] compile without pie
01:02:01 [Task3] file main
01:02:03 [Task3] file main_angr
01:02:27 [Task3] load binary to ghidra
01:02:56 [Task3] edit x.py
import angr
import claripy
p = angr.Project('./main_angr')
f = angr.SimFile('symbolic_stdin', size=0x200)
entry = p.factory.entry_state(stdin=f)
s = p.factory.simgr()
avoids = [0x40184b,]
s.explore(n=1000, avoid=avoids)
01:03:36 [Task3] analyze source code (focus on main)
01:04:05 [Task3] edit x.py
import angr
import claripy
p = angr.Project('./main_angr')
f = angr.SimFile('symbolic_stdin', size=0x200)
entry = p.factory.entry_state(stdin=f)
s = p.factory.simgr()
avoids = [0x40184b,]
s.explore(n=1000, avoid=avoids)
import IPython
IPython.embed(baner1='')
01:04:24 [Task3] pip install ipython
01:04:35 [Task3] edit x.py
#!/usr/bin/env python3
import angr
import claripy
p = angr.Project('./main_angr')
f = angr.SimFile('symbolic_stdin', size=0x200)
entry = p.factory.entry_state(stdin=f)
s = p.factory.simgr()
avoids = [0x40184b,]
s.explore(n=1000, avoid=avoids)
import IPython
IPython.embed(baner1='')
01:04:43 [Task3] chmod +x x.py
01:04:46 [Task3] ./x.py
01:07:09 [Task3] stop simulation
01:07:12 [Task3] edit x.py
#!/usr/bin/env python3
import angr
import claripy
p = angr.Project('./main_angr')
f = angr.SimFile('symbolic_stdin', size=0x200)
entry = p.factory.entry_state(stdin=f, add_options={angr.options.STRICT_PAGE_ACCESS})
s = p.factory.simgr(entry)
avoids = [0x40184b,]
try:
    for i in range(1000):
        s.step(avoid=avoids)
        print(i, s)
except KeyboardInterupt:
    print('\nKBD INTERTUPT')
    break
import IPython
IPython.embed(baner1='')
01:11:04 [Task3] ./x.py
01:11:10 [Task3] edit x.py
#!/usr/bin/env python3
import angr
import claripy
p = angr.Project('./main_angr')
f = angr.SimFile('symbolic_stdin', size=0x200)
entry = p.factory.entry_state(stdin=f, add_options={angr.options.STRICT_PAGE_ACCESS})
s = p.factory.simgr(entry)
avoids = [0x40184b,]
try:
    for i in range(1000):
        s.step(avoid=avoids)
        print(i, s)
except KeyboardInterupt:
    print('\nKBD INTERRUPT')
import IPython
IPython.embed(baner1='')
01:11:18 [Task3] ./x.py
01:13:21 [Task3] stop simulation
01:13:26 [Task3] edit x.py
#!/usr/bin/env python3
import angr
import claripy
p = angr.Project('./main_angr')
f = angr.SimFile('symbolic_stdin', size=0x200)
entry = p.factory.entry_state(stdin=f, add_options={angr.options.STRICT_PAGE_ACCESS})
s = p.factory.simgr(entry)
avoids = [0x40184b,]
try:
    for i in range(1000):
        s.step(avoid=avoids)
        print(i, s)
except KeyboardInterrupt:
    print('\nKBD INTERRUPT')
import IPython
IPython.embed(baner1='')
01:13:30 [Task3] ./x.py
01:14:48 [Task3] stop simulation
01:14:50 [Task3] s
01:14:53 [Task3] s.deadended
01:15:05 [Task3] search for 0x800058 in ghidra
01:15:42 [Task3] analyze source code
01:16:21 [Task3] edit main.c
add line 173: printf("not unloading %s\n", mod->name);
01:17:04 [Task3] edit e.py
#!/usr/bin/env python3
from pwn import *
def insmod(name, deps):
    r.send('I')
    r.send(name.ljust(1, b'\0'))
    r.send(deps.ljust(9, n'\0'))
r = process('./main')
t.interactive()
01:18:48 [Task3] exit simulation
01:18:54 [Task3] run program
01:19:00 [Task3] compile with address-sanitizer
01:19:21 [Task3]run program
01:19:30 [Task3] edit e.py
#!/usr/bin/env python3
from pwn import *
def recvlist():
    res = b''
    while 1:
        line = r.recvline(timeout=0.05)
        if not line:
            return res
        res += line
def insmod(name, deps):
    r.send('I')
    r.send(name.ljust(1, b'\0'))
    r.send(deps.ljust(9, b'\0'))
    print(recvlist().decode())
def rmmod(name):
    r.send('D')
    r.send(name.ljust(1, b'\0'))
    print(recvlist().decode())
def lsmod():
    r.send('L')
    print(recvlist().decode())
r = process('./main')
try:
    while 1:
        cmd = input().strip()
        assert cmd[0] in b"IDL'
        if cmd[0] == b'I':
            mod, deps = cmd.split()
            cmd = cmd.encode()
            mod = mod.encode()
            deps = deps.encode().replace(b'.', b'\0')
            assert len(deps) <= 9
            assert len(mod) <= 1
             insmod(mod, deps)
        elif cmd[0] == b'L':
            lsmod()
        else:
            mod, deps = cmd.split()
            cmd = cmd.encode()
            mod = mod.encode()
            assert len(mod) <= 1
            rmmod(mod)
except KeyboardInterrupt:
    pass
t.interactive()
01:26:44 [Task3] pip install pwntools
01:27:08 [Task3] ./e.py
01:27:14 [Task3] edit e.py
#!/usr/bin/env python3
from pwn import *
def recvlist():
    res = b''
    while 1:
        line = r.recvline(timeout=0.05)
        if not line:
            return res
        res += line
def insmod(name, deps):
    r.send('I')
    r.send(name.ljust(1, b'\0'))
    r.send(deps.ljust(9, b'\0'))
    print(recvlist().decode())
def rmmod(name):
    r.send('D')
    r.send(name.ljust(1, b'\0'))
    print(recvlist().decode())
def lsmod():
    r.send('L')
    print(recvlist().decode())
r = process('./main')
try:
    while 1:
        cmd = input().strip()
        assert cmd[0] in b"ID'
        cmd = cmd.encode()
        if cmd[0] == b'I':
            cmd, mod, deps = cmd.split()
            deps = deps.encode().replace(b'.', b'\0')
            assert len(deps) <= 9
            assert len(mod) <= 1
             insmod(mod, deps)
#        elif cmd[0] == b'L':
 #           lsmod()
        else:
            cmd, mod = cmd.split()
            assert len(mod) <= 1
            rmmod(mod)
except KeyboardInterrupt:
    pass
t.interactive()
01:28:39 [Task3] ./e.py
01:28:41 [Task3] input "I A" **
01:29:10 [Task3] input "D A"
01:29:26 [Task3] search for "can't rm" in source code
01:29:45 [Task3] ./e.py DEBUG
01:29:46 [Task3] input "I A"
01:30:04 [Task3] edit e.py
#!/usr/bin/env python3
from pwn import *
def recvlist():
    res = b''
    while 1:
        line = r.recvline(timeout=0.05)
        if not line:
            return res
        res += line
def insmod(name, deps):
    r.send('I')
    r.send(name.ljust(1, b'\0'))
    r.send(deps.ljust(9, b'\0'))
    print(recvlist().decode())
def rmmod(name):
    r.send('D')
    r.send(name.ljust(1, b'\0'))
    print(recvlist().decode())
def lsmod():
    r.send('L')
    print(recvlist().decode())
r = process('./main')
try:
    while 1:
        cmd = input().strip()
        print(cmd[0])
        assert cmd[0] in b"ID'
        cmd = cmd.encode()
        if cmd[0] == b'I':
            cmd, mod, deps = cmd.split()
            deps = deps.encode().replace(b'.', b'\0')
            assert len(deps) <= 9
            assert len(mod) <= 1
             insmod(mod, deps)
#        elif cmd[0] == b'L':
 #           lsmod()
        else:
            cmd, mod = cmd.split()
            assert len(mod) <= 1
            rmmod(mod)
except KeyboardInterrupt:
    pass
t.interactive()
01:30:36 [Task3] ./e.py DEBUG
01:30:37 [Task3] input "I A"
01:30:51 [Task3] edit e.py
#!/usr/bin/env python3
from pwn import *
def recvlist():
    res = b''
    while 1:
        line = r.recvline(timeout=0.05)
        if not line:
            return res
        res += line
def insmod(name, deps):
    r.send('I')
    r.send(name.ljust(1, b'\0'))
    r.send(deps.ljust(9, b'\0'))
    print(recvlist().decode())
def rmmod(name):
    r.send('D')
    r.send(name.ljust(1, b'\0'))
    print(recvlist().decode())
def lsmod():
    r.send('L')
    print(recvlist().decode())
r = process('./main')
try:
    while 1:
        cmd = input().strip()
        print(cmd[0])
        assert cmd[0] in b"ID'
        cmd = cmd.encode()
        if cmd[0] == b'I':
            print("# doing insmod")
            cmd, mod, deps = cmd.split()
            deps = deps.encode().replace(b'.', b'\0')
            assert len(deps) <= 9
            assert len(mod) <= 1
             insmod(mod, deps)
#        elif cmd[0] == b'L':
 #           lsmod()
        else:
            cmd, mod = cmd.split()
            assert len(mod) <= 1
            rmmod(mod)
except KeyboardInterrupt:
    pass
t.interactive()
01:31:02 [Task3] ./e.py DEBUG
01:31:04 [Task3] input "I A"
01:31:10 [Task3] edit e.py
#!/usr/bin/env python3
from pwn import *
def recvlist():
    res = b''
    while 1:
        line = r.recvline(timeout=0.05)
        if not line:
            return res
        res += line
def insmod(name, deps):
    r.send('I')
    r.send(name.ljust(1, b'\0'))
    r.send(deps.ljust(9, b'\0'))
    print(recvlist().decode())
def rmmod(name):
    r.send('D')
    r.send(name.ljust(1, b'\0'))
    print(recvlist().decode())
def lsmod():
    r.send('L')
    print(recvlist().decode())
r = process('./main')
try:
    while 1:
        cmd = input().strip()
        print(cmd[0])
        assert cmd[0] in b"ID'
        cmd = cmd.encode()
        if cmd[0:1] == b'I':
            print("# doing insmod")
            cmd, mod, deps = cmd.split()
            deps = deps.encode().replace(b'.', b'\0')
            assert len(deps) <= 9
            assert len(mod) <= 1
             insmod(mod, deps)
#        elif cmd[0] == b'L':
 #           lsmod()
        else:
            cmd, mod = cmd.split()
            assert len(mod) <= 1
            rmmod(mod)
except KeyboardInterrupt:
    pass
t.interactive()
01:31:18 [Task3] ./e.py DEBUG
01:31:19 [Task3] input "I A"
01:31:25 [Task3] input "I A"
01:31:33 [Task3] input "I A"
01:31:35 [Task3] input "I A A"
01:31:39 [Task3] input "I X A"
01:31:45 [Task3] input "I X X"
01:31:54 [Task3] input "D A"
01:32:03 [Task3] ./e.py
01:32:04 [Task3] input "I X A"
01:32:06 [Task3] input "D X"
01:32:08 [Task3] input "I X A"
01:32:10 [Task3] input "I X A"
01:32:14 [Task3] input "I Y X"
01:32:16 [Task3] input "I X Y"
01:32:25 [Task3] input  "I a B"
01:32:36 [Task3] input "D a"
01:32:42 [Task3] input "D X"
01:32:49 [Task3] input "D a"
01:32:53 [Task3] input "D Y"
01:32:56 [Task3] input "D ."
01:33:03 [Task3] edit e.py
#!/usr/bin/env python3
from pwn import *
def recvlist():
    res = b''
    while 1:
        line = r.recvline(timeout=0.05)
        if not line:
            return res
        res += line
def insmod(name, deps):
    r.send('I')
    r.send(name.ljust(1, b'\0'))
    r.send(deps.ljust(9, b'\0'))
    print(recvlist().decode())
def rmmod(name):
    r.send('D')
    r.send(name.ljust(1, b'\0'))
    print(recvlist().decode())
def lsmod():
    r.send('L')
    print(recvlist().decode())
r = process('./main')
try:
    while 1:
        cmd = input().strip()
        print(cmd[0])
        assert cmd[0] in b"ID'
        cmd = cmd.encode()
        cmd = cmd.replace(b'.', b'\0')
        if cmd[0:1] == b'I':
            print("# doing insmod")
            cmd, mod, deps = cmd.split()
            assert len(deps) <= 9
            assert len(mod) <= 1
             insmod(mod, deps)
#        elif cmd[0] == b'L':
 #           lsmod()
        else:
            cmd, mod = cmd.split()
            assert len(mod) <= 1
            rmmod(mod)
except KeyboardInterrupt:
    pass
t.interactive()
01:33:18 [Task3] ./e.py
01:33:23 [Task3] input "D ."
01:33:28 [Task3] input "D ."
01:33:30 [Task3] input "I ."
01:33:35 [Task3] ./e.py
01:33:36 [Task3] input "I . ."
01:33:37 [Task3] input "D ."
01:33:43 [Task3] input "I . ."
01:33:44 [Task3] input "I . ."
01:33:46 [Task3] input "I . ."
01:33:49 [Task3] input "D ."
01:33:53 [Task3] input "I x ."
01:33:57 [Task3] input "I . x"
01:34:04 [Task3] input "I . . x"
01:34:18 [Task3] scroll through source code
01:34:43 [Task3] compile
01:34:53 [Task3] ./e.py
01:34:59 [Task3] input "I A x"
01:35:08 [Task3] search for "grub_dl_unload" in source code
01:35:11 [Task3] scroll through source code
01:36:06 [Task3] edit main.c
add line 177: print("unloading %s\n", mod->name);
01:36:20 [Task3] compile
01:36:22 [Task3] ./e.py
01:36:24 [Task3] input "I A ."
01:36:29 [Task3] input "I x ."
01:36:35 [Task3] input "I x z"
01:36:43 [Task3] scroll through source code (focus on grub_dl_resolve_dependencies)
01:38:18 [Task3] input "D x"
01:38:23 [Task3] input "D x"
01:38:25 [Task3] input "D D"

01:38:35 [Task3] scroll through source code
01:39:03 [Task3] input "I C ."
01:39:09 [Task3] edit e.py
#!/usr/bin/env python3
from pwn import *
def recvlist():
    res = b''
    while 1:
        line = r.recvline(timeout=0.05)
        if not line:
            return res
        res += line
def insmod(name, deps):
    r.send('I')
    r.send(name.ljust(1, b'\0'))
    r.send(deps.ljust(9, b'\0'))
    print(recvlist().decode())
def rmmod(name):
    r.send('D')
    r.send(name.ljust(1, b'\0'))
    print(recvlist().decode())
def lsmod():
    r.send('L')
    print(recvlist().decode())
r = process('./main')
try:
    while 1:
        cmd = input().strip()
        assert cmd[0] in b"ID'
        cmd = cmd.encode()
        cmd = cmd.replace(b'.', b'\0')
        if cmd[0:1] == b'I':
            print("# doing insmod")
            cmd, mod, deps = cmd.split()
            assert len(deps) <= 9
            assert len(mod) <= 1
             insmod(mod, deps)
#        elif cmd[0] == b'L':
 #           lsmod()
        else:
            cmd, mod = cmd.split()
            assert len(mod) <= 1
            rmmod(mod)
except KeyboardInterrupt:
    pass
t.interactive()
01:39:14 [Task3] ./e.py
01:39:16 [Task3] input "I C ."
01:39:27 [Task3] scroll through source code
